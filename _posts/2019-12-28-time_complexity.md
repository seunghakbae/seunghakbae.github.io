---
layout: post
title: 시간복잡도(Time Complexity) 계산하기
tags:  [algorithm-and-data-structure]
---
어떤 알고리즘 문제가 있다고 하자. 이 알고리즘 문제를 푸는 데 **여러가지 방식이 존재** 할 수 있다. 예를 들어,

정수의 절대값을 구하는 문제가 있다라고 하자.
방법 1. 정수값을 제곱한 뒤에 다시 루트를 씌우기.
방법 2. 정수가 음수인지 확인해서 음수일 때만 -1을 곱하기.

그렇다면, 어느 방법이 더 나은 방법일까? 알고리즘 문제를 접근할 때 측정도구가 되는 존재가 바로 **알고리즘 복잡도** 이다!

> 다양한 알고리즘 중 어느 알고리즘이 더 좋은지를 분석하기 위해 **복잡도를 정의하고 계산** 한다. 프로그램을 작성할 때에도 가장 빠르게 작동하는 프로그램이 좋은 것처럼, 이런 시간을 측정하는 것이 **알고리즘 복잡도** 이다.  

## 알고리즘 복잡도 계산
알고리즘 복잡도를 계산하는 방법은 2가지가 있다.

###### **1. 시간 복잡도 : 알고리즘 실행속도**
###### 2. 공간 복잡도 : 알고리즘이 사용하는 메모리 사이즈

공간 복잡도는 거의 물어보는 경우는 없으며 계산하기도 어렵다. 그래서 대부분 **시간 복잡도를 기준** 으로 측정을 한다.

> ##### 알고리즘 시간 복잡도의 주요 요소 : 반복문이 지배한다.

예를 들어, 자동차로 서울에서 부산을 가기 위해, 다음과 같이 항목을 나누었을 때, 가장 총 시간에 영향을 미칠것 같은 요소는?

1. 자동차로 문열기
2. 자동차 문닫기
3. 자동차 운전석 등받이 조정하기
4. 자동차 시동걸기
5. **자동차로 서울에서 부산가기**
6. 자동차 시동끄기
7. 자동차 문열기
8. 자동차 문닫기

사실 5번을 제외하고는 총 시간에 미치는 거의 미미하다. 알고리즘 문제에서는 **5번이 바로 반복문에 해당** 된다.
프로그래밍에서 시간 복잡도에 가장 영향을 미치는 것은 반복문이다. **입력의 크기가 커지면 반복문이 알고리즘 수행 시간을 지배한다.**

&nbsp;
&nbsp;

## 알고리즘 성능 표기법
알고리즘 성능 표기법은 크게 3가지가 있다.

###### **1. Big O(빅-오) 표기법 : O(N)**
  * 알고리즘의 **최악의 실행 시간** 을 표기한다. (알고리즘에 어떻게 입력 되는가에 따라서 최악으로 시간이 걸렸을 때를 상정)
  * 반대로 의미하면, 아무리 최악의 상황이라도 이정도의 성능은 보장한다는 의미이다.

###### **2. Ω(오메가) 표기법 : Ω(N)**
  * 오메가 표기법은 알고리즘 최상의 실행 시간을 표기한다.

###### **3. θ(세타) 표기법 : θ(N)**
  * 세타 표기법은 알고리즘 평균 실행 시간을 표기한다.

시간 복잡도 계산은 반복문이 핵심이다. 그리고 이 반복문의 계산 표기는 크게 최상, 평균, 최악의 시간을 기준으로 평가한다. 주로, **최악의 시간인 Big-O 표기법** 을 사용한다.

> #### 빅-오 표기법

빅오 표기법, Big-O 표기법이라고 한다. 입력 n에 따라 결정되는 시간 복잡도 함수이다. 단순하게 **입력 n에 따라 몇번 실행이 되는 지를 계산하면 된다**.
입력 n의 크기에 따라 기하급수적으로 시간 복잡도가 늘어 날 수 있다.
**O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(2^n) < O(n!) (참고로 log n의 베이스는 2이다)**

표현식에 가장 큰 영향을 미치는 n의 단위로 표기를 한다.

![Alt text](/public/time_complexity.png)


&nbsp;

### 예시
##### n이 1이든, 100이든, 1000이든, 10000이든 실행을 무조건 2회(상수회) 실행한다 : O(1)
~~~python
def gets(n):
  if n > 10:
    print(n)
~~~
만약 이런 함수가 있다고 하자. 이 함수는 n이 어떤 값이든 상관 없이 코드는 2번 실행이 된다. 이런 경우 **O(1)** 로 표기를 한다. 즉, N이 1이든, 10이든, 100이든 무조건 2회 실행한다.

##### n에 따라, n번, n+10번, 또는 3n+10번등 실행한다: O(n)

~~~python
def print_all(n):
  for num in n:
    print(n)
~~~
위와 같은 함수는 n의 입력값에 따라 실행되는 횟수가 달라진다. 이럴 경우 입력값 n에 의해 시간 복잡도가 결정 되므로 **O(n)** 의 시간 복잡도를 가진다.

~~~python
    variable = 1
    for index in range(n):
        print(index)
~~~~

예를 들어, 2번째 같은 경우 **n + 1번** 실행된다. (variable = 1이라는 코드가 한 줄 더 추가된다)


~~~python
    variable = 1
    for num in range(3):
        for index in range(n):
            print(index)
~~~~
위의 함수 경우 n번 loop이 3번 반복된다. 이럴 경우 총 **3n+1번**  실행된다.

##### n에 따라, n^2번, n^2 + 1000번, 또는 100n^2 - 100번등 실행한다 : O(n^2)
~~~python
variable = 1
for num in range(n):
   for index in range(n):
       print(index)
~~~~

위의 경우 n이 두번 실행 되므로, n^2이 된다.

~~~python
   variable = 1
   for i in range(300):
       for num in range(n):
           for index in range(n):
               print(index)
~~~~
위는 300n^2 + 1의 time complexity를 가진다.

**만약 시간 복잡도 함수가 2n^2 + 3n이라면 어떨까?**
가장 높은 차수는 2n^2이다. 상수는 사실상 큰 영향이 없다. 그리고 n이 증가하는 것 보다 n^2가 증가하는 속도가 훨씬 빠르다. 그러므로, 빅오는 O(n^2)로 표기를 하면 된다.
