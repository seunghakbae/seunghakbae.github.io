---
layout: post
title: 기타리스트 (1495)
tags:  [algorithm-problem]
---

[1495문제](https://www.acmicpc.net/problem/1495)


### 문제
Day Of Mourning의 기타리스트 강토는 다가오는 공연에서 연주할 N개의 곡을 연주하고 있다. 지금까지 공연과는 다른 공연을 보여주기 위해서 이번 공연에서는 매번 곡이 시작하기 전에 볼륨을 바꾸고 연주하려고 한다.

먼저, 공연이 시작하기 전에 각각의 곡이 시작하기 전에 바꿀 수 있는 볼륨의 리스트를 만들었다. 이 리스트를 V라고 했을 때, V[i]는 i번째 곡을 연주하기 전에 바꿀 수 있는 볼륨을 의미한다. 항상 리스트에 적힌 차이로만 볼륨을 바꿀 수 있다. 즉, 현재 볼륨이 P이고 지금 i번째 곡을 연주하기 전이라면, i번 곡은 P+V[i]나 P-V[i] 로 연주해야 한다. 하지만, 0보다 작은 값으로 볼륨을 바꾸거나, M보다 큰 값으로 볼륨을 바꿀 수 없다.

곡의 개수 N과 시작 볼륨 S, 그리고 M이 주어졌을 때, 마지막 곡을 연주할 수 있는 볼륨 중 최댓값을 구하는 프로그램을 작성하시오. 모든 곡은 리스트에 적힌 순서대로 연주해야 한다.

&nbsp;


### 입력
첫째 줄에 N, S, M이 주어진다. (1 ≤ N ≤ 100, 1 ≤ M ≤ 1000, 0 ≤ S ≤ M) 둘째 줄에는 각 곡이 시작하기 전에 줄 수 있는 볼륨의 차이가 주어진다. 이 값은 1보다 크거나 같고, M보다 작거나 같다.
&nbsp;

### 출력
첫째 줄에 가능한 마지막 곡의 볼륨 중 최댓값을 출력한다. 만약 마지막 곡을 연주할 수 없다면 (중간에 볼륨 조절을 할 수 없다면) -1을 출력한다.

&nbsp;

### 파이썬 코드

차례대로 곡을 연주한다는 점에서, 동적 프로그래밍으로 해결할 수 있는 문제이다 .

곡의 개수가 N, 볼륨의 최댓값은 M이다.

동적 프로그래밍을 이용하여 시간복잡도 O(NM)으로 문제를 해결 할 수 있다.

핵심아이디어 : **모든 볼륨** 에 대하여 연주 가능 여부를 계산하기.

D[i][j+1] = i번째 노래일 때, j크기의 볼륨으로 연주 가능하지 여부

노래를 순서대로 확인하며, 매 번 모든 크기의 볼륨에 대하여 검사한다.

![Alt text](/public/post/2020_01_15_1495/howto_1.png)

시작 볼륨이 5이다. 처음엔 다 False를 넣어주고 시작 볼륨에만 True값을 넣어준다.

![Alt text](/public/post/2020_01_15_1495/howto_2.png)

이제 볼륨이 5일 때 연주를 할 수 있었다. 그래서 5에서 5만큼 뺀 0의 위치의 값이 True가 되고 10의 값에 True가 들어간다.

![Alt text](/public/post/2020_01_15_1495/howto_3.png)

이제 2번째 곡같은 경우엔 이전 곡에서 연주할 수 있던 볼륨에 대해서 3만큼 더하고 빼기를 반복하면 된다. 그래서 True가 된것만 다 연주할 수 있는 것이라고 할 수 있다.

![Alt text](/public/post/2020_01_15_1495/howto_4.png)

결과적으로 마지막 곡에서 연주 할 수 있는 곡의 볼륨은 0과 10이 된다. 그 중 가장 큰 값이 10이기 때문에 10이 된다.

![Alt text](/public/post/2020_01_15_1495/howto_5.png)

~~~python
n, s, m = map(int, input().split())
array = list(map(int, input().split()))

dp = [[0] * (m + 1) for _ in range(n + 1)]
dp[0][s] = 1

for i in range(1, n + 1):
    for j in range(m + 1):
        if dp[i-1][j] == 0:
            continue
        if j - array[i - 1] >= 0:
            dp[i][j - array[i - 1]] = 1
        if j + array[i - 1] <= m:
            dp[i][j + array[i - 1]] = 1

result = -1

for i in range(m, -1, -1):
    if dp[n][i] == 1:
        result = i
        break

print(result)
~~~
