---
layout: post
title: Data Science Math - 1.3 수열의 집합의 합과 곱
tags: [data-science]
---
# 데이터와 행렬
**선형대수(linear algebra)는** 데이터 분석에 필요한 각종 계산을 돕는 학문이다. 데이터 분석을 하려면 수많은 숫자로 이루어진 데이터를 다루어야 한다.

**선형대수를 사용하면 대량의 데이터를 포함하는 복잡한 계산 과정을 몇 글자 되지 않는 간단한 수식으로 서술할 수 있다.**

&nbsp;
&nbsp;
&nbsp;

# 데이터의 유형
선형대수에서 다루는 데이터는 개수나 형태에 따라서 크게 **스칼라(scalar), 벡터(vector), 행렬(matrix), 텐서(tensor)** 유형으로 나뉜다.

**스칼라** 는 **숫자 하나로 이루어진 데이터** 이고, **벡터** 는 **여러 숫자로 이루어진 데이터 레코드(data record)** 이며, **행렬은** 이러한 벡터, **즉 데이터 레코드가 여럿인 데이터 집합** 이라고 볼 수 있다.

&nbsp;
&nbsp;
&nbsp;

# 스칼라
**스칼라는 하나의 숫자만으로 이루어진 데이터를 말한다.** 예를 들어, 어떤 붓꽃 한 송이의 꽃잎 길이를 측정하면 숫자가 하나 나올것이다. 이 데이터는 스칼라이다. 스칼라는 보통 x와 같이 알파벳 소문자로 표기하며 실수(real number)인 숫자 중의 하나이므로 실수 집합 **R** 의 원소라는 의미에서 다음처럼 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic_1.PNG)

&nbsp;
&nbsp;

# 벡터
벡터는 여러 개의 숫자가 특정한 순서대로 모여 있는 것을 말한다. 예를 들어, 붓꽃의 종을 알아내기 위해 붓꽃의 크기를 측정할 때, 꽃받침의 길이 x1뿐 아니라 꽃받침의 폭 x2, 꽃잎의 길이 x3, 꽃잎의 폭 x4라는 4개의 숫자를 측정할 수도 있다. 이렇게 측정된 4개의 숫자는 한 송이의 붓꽃에서 나온 데이터이므로 따로따로 다루기보다는 하나의 묶음(tuple)으로 묶어놓는 것이 좋다. 이때 숫자의 순서가 바뀌면 어떤 숫자가 꽃잎의 길이이고 어떤 숫자가 꽃받침의 폭인지 알 수 없으므로 숫자의 순서를 유지하는 것이 중요하다. **이런 데이터 묶음을 선형대수에서는 벡터라고 부른다.**

벡터는 복수의 가로줄, 즉 **행(row)을 가지고 하나의 세로줄, 즉 열(column)을 가지는 형태로 위에서 아래로 내려써서 표기해야** 한다.

하나의 벡터를 이루는 데이터의 개수가 n개이면 이 벡터를 **n-차원 벡터(n-dimensional vector)** 라고 하면 다음처럼 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic2.PNG)

#### 특징 벡터
__데이터 벡터가 예측 문제에서 입력 데이터로 사용되면 특징 벡터(feature vector)__ 라고 한다.

&nbsp;
&nbsp;
&nbsp;

# 넘파이를 사용한 벡터 표현
넘파이를 사용하여 벡터를 표현할 때는 벡터를 다음처럼 열의 개수가 하나인 2차원 배열(array)객체로 표현한다.

이때 __배열의 차원은 벡터의 차원과 다른 의미다.__ 위에서 설명한 __벡터의 차원은 원소 개수__ 를 뜻한다. 배열은 __원소 개수가 몇 개이든 한 줄로 나타낼 수 있다면 1차원 배열이라고__ 한다. 원소를 __가로와 세로가 있는 여러 줄의 직사각형 형태로 나타낼 수 있으면 2차원 배열__ 이라고 한다.

예를 들어, 다음과 같은 4차원 벡터를 2차원 배열로 표기하면 다음과 같다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic4.PNG)

~~~python
x1 = np.array([[5.1], [3.5], [1.4], [0.2]])
x1
~~~

~~~
array([[5.1],
       [3.5],
       [1.4],
       [0.2]])
~~~

하지만 넘파이는 1차원 배열 객체도 대부분 벡터로 인정한다. 이때는 벡터가 마치 하나의 행처럼 표시되어도 실제로는 열이라는 점에 주의한다.

~~~python
x1 = np.array([5.1, 3.5, 1.4, 0.2])
x1
~~~

~~~
array([5.1, 3.5, 1.4, 0.2])
~~~
