---
layout: post
title: Data Science Math - 2.1 데이터와 행렬
tags: [data-science]
---
# 데이터와 행렬
**선형대수(linear algebra)는** 데이터 분석에 필요한 각종 계산을 돕는 학문이다. 데이터 분석을 하려면 수많은 숫자로 이루어진 데이터를 다루어야 한다.

**선형대수를 사용하면 대량의 데이터를 포함하는 복잡한 계산 과정을 몇 글자 되지 않는 간단한 수식으로 서술할 수 있다.**

&nbsp;
&nbsp;
&nbsp;

# 데이터의 유형
선형대수에서 다루는 데이터는 개수나 형태에 따라서 크게 **스칼라(scalar), 벡터(vector), 행렬(matrix), 텐서(tensor)** 유형으로 나뉜다.

**스칼라** 는 **숫자 하나로 이루어진 데이터** 이고, **벡터** 는 **여러 숫자로 이루어진 데이터 레코드(data record)** 이며, **행렬은** 이러한 벡터, **즉 데이터 레코드가 여럿인 데이터 집합** 이라고 볼 수 있다.

&nbsp;
&nbsp;
&nbsp;

# 스칼라
**스칼라는 하나의 숫자만으로 이루어진 데이터를 말한다.** 예를 들어, 어떤 붓꽃 한 송이의 꽃잎 길이를 측정하면 숫자가 하나 나올것이다. 이 데이터는 스칼라이다. 스칼라는 보통 x와 같이 알파벳 소문자로 표기하며 실수(real number)인 숫자 중의 하나이므로 실수 집합 **R** 의 원소라는 의미에서 다음처럼 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic1.PNG)

&nbsp;
&nbsp;

# 벡터
벡터는 여러 개의 숫자가 특정한 순서대로 모여 있는 것을 말한다. 예를 들어, 붓꽃의 종을 알아내기 위해 붓꽃의 크기를 측정할 때, 꽃받침의 길이 x1뿐 아니라 꽃받침의 폭 x2, 꽃잎의 길이 x3, 꽃잎의 폭 x4라는 4개의 숫자를 측정할 수도 있다. 이렇게 측정된 4개의 숫자는 한 송이의 붓꽃에서 나온 데이터이므로 따로따로 다루기보다는 하나의 묶음(tuple)으로 묶어놓는 것이 좋다. 이때 숫자의 순서가 바뀌면 어떤 숫자가 꽃잎의 길이이고 어떤 숫자가 꽃받침의 폭인지 알 수 없으므로 숫자의 순서를 유지하는 것이 중요하다. **이런 데이터 묶음을 선형대수에서는 벡터라고 부른다.**

벡터는 복수의 가로줄, 즉 **행(row)을 가지고 하나의 세로줄, 즉 열(column)을 가지는 형태로 위에서 아래로 내려써서 표기해야** 한다.

하나의 벡터를 이루는 데이터의 개수가 n개이면 이 벡터를 **n-차원 벡터(n-dimensional vector)** 라고 하면 다음처럼 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic2.PNG)

#### 특징 벡터
__데이터 벡터가 예측 문제에서 입력 데이터로 사용되면 특징 벡터(feature vector)__ 라고 한다.

&nbsp;
&nbsp;
&nbsp;

# 넘파이를 사용한 벡터 표현
넘파이를 사용하여 벡터를 표현할 때는 벡터를 다음처럼 열의 개수가 하나인 2차원 배열(array)객체로 표현한다.

이때 __배열의 차원은 벡터의 차원과 다른 의미다.__ 위에서 설명한 __벡터의 차원은 원소 개수__ 를 뜻한다. 배열은 __원소 개수가 몇 개이든 한 줄로 나타낼 수 있다면 1차원 배열이라고__ 한다. 원소를 __가로와 세로가 있는 여러 줄의 직사각형 형태로 나타낼 수 있으면 2차원 배열__ 이라고 한다.

예를 들어, 다음과 같은 4차원 벡터를 2차원 배열로 표기하면 다음과 같다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic4.PNG)

~~~python
x1 = np.array([[5.1], [3.5], [1.4], [0.2]])
x1
~~~

~~~
array([[5.1],
       [3.5],
       [1.4],
       [0.2]])
~~~

하지만 넘파이는 1차원 배열 객체도 대부분 벡터로 인정한다. 이때는 벡터가 마치 하나의 행처럼 표시되어도 실제로는 열이라는 점에 주의한다.

~~~python
x1 = np.array([5.1, 3.5, 1.4, 0.2])
x1
~~~

~~~
array([5.1, 3.5, 1.4, 0.2])
~~~
&nbsp;
&nbsp;
&nbsp;

# 행렬
행렬은 복수의 차원을 가지는 데이터 레코드가 다시 여러 개 있는 경우의 데이터를 합쳐서 표기한 것이다.

예를 들어, 붓꽃 6 송이에 대해 꽃잎과 꽃받침의 크기를 측정하였다면 4차원 붓꽃 데이터가 6개가 있다. 즉,  4×6=24 개의 실수 숫자가 있는 것이다. 이 숫자 집합을 행렬로 나타내면 다음과 같다. 행렬은 보통  X 와 같이 알파벳 대문자로 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic5.PNG)

**벡터는 열의 수가 1인 행렬이라고 볼 수 있으므로 벡터를 다른 말로 열 벡터(column vector)라고도 한다.**

또한 데이터를 행렬로 묶어서 표시할 때는 붓꽃 하나에 대한 데이터 레코드, 즉 **하나의 벡터가 열이 아닌 행(row)으로 표시한다.**

**즉, 하나의 데이터 레코드를 단독으로 벡터로 나타낼 때는 하나의 열(column)** 로 나타내고 **복수의 데이터 레코드 집합을 행렬로 나타낼 때는 하나의 데이터 레코드가 하나의 행(row)** 으로 표기한다.

만약 이 데이터를 이용하여 붓꽃의 종을 결정하는 예측 문제를 풀고 있다면 이 행을 **특징 행렬(feature matrix)이라고** 하기도 한다. 이 행렬의 크기를 수식으로 표시할 때는 다음처럼 **"행의 크기 곱하기 열의 크기"로 나타낸다.**

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic6.PNG)

~~~python
A = np.array([[11, 12, 13], [21, 22, 23]])

A
~~~

~~~
array([[11, 12, 13],
       [21, 22, 23]])
~~~

&nbsp;
&nbsp;
&nbsp;

# 텐서
**텐서는 같은 크기의 행렬이 여러 개 같이 묶여 있는 것을 말한다.** 엄격한 수학적 정의로는 텐서는 다차원 배열로 표현되는 사상(mapping)으로 다차원 배열 자체를 뜻하지 않는다.

~~~python
from scipy import misc  # 패키지 임포트

img_rgb = misc.face()  # 컬러 이미지 로드
img_rgb.shape  # 데이터의 모양
~~~

~~~
(768, 1024, 3)
~~~

&nbsp;
&nbsp;
&nbsp;

# 전치 연산
스칼라, 벡터, 행렬 데이터를 변형시키는 방법, 연산(operation)에 대해서 알아보자. **전치(transpose) 연산은 행렬에서 가장 기본이 되는 연산으로 행렬의 행과 여을 바꾸는 연산** 을 말한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic7.PNG)

예를 들어, 앞에서 보인 6 x 4 차원의 행렬을 전치 연산하면 4 x 6 차원의 행렬이 된다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic8.PNG)

(열)벡터 x에 대해 전치 연산을 적용하여 만든 x^T는 행의 수가 1인 행렬이므로 **행 벡터(row vector)** 라고 한다.

numpy에서는 ndarray 객체의 T라는 속성을 이용하여 전치 행렬을 구한다.

&nbsp;
&nbsp;
&nbsp;

# 행렬의 행 표기법과 열 표기법
전치 연산과 행 벡터, 열 벡터를 이용하면 다음처럼 행렬을 복수의 열 벡터  ci , 또는 복수의 행 벡터  rTj  을 합친(concatenated) 형태로 표기할 수도 있다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic9.PNG)

위 식에서 행렬과 벡터의 크기는 다음과 같다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic10.PNG)

벡터의 모양을 직사각형으로 표시하면 다음과 같다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic11.PNG)

예를 들어 행렬

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic12.PNG)

은 열 벡터

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic13.PNG)

이 합쳐진 것이라고 보거나 또는 행 벡터

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic14.PNG)

로 구성되었다고 볼 수 있다.

&nbsp;
&nbsp;
&nbsp;

# 특수한 벡터와 행렬

### 영벡터
모든 원소가 0인  N 차원 벡터는 **영벡터(zeros-vector)라고** 하며 다음처럼 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic15.PNG)

~~~python
np.zeros((5,5))
~~~

~~~
array([[0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.],
       [0., 0., 0., 0., 0.]])
~~~

### 일벡터
모든 원소가 1인  N 차원 벡터는 **일벡터(ones-vector)라고** 하며 다음처럼 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic16.PNG)

~~~python
np.ones((3,1))
~~~

~~~
array([[1.],
       [1.],
       [1.]])
~~~

### 정방행렬(square matrix)
행의 개수와 열의 개수가 같은 행렬을 **정방행렬 (square matrix)** 라고 한다.

### 대각행렬(diagonal matrix)
행렬에서 행과 열이 같은 위치를 **주 대각(main diagonal)** 또는 간단히 **대각(diagonal)** 이라고 한다. 대각 위치에 있지 않은 것들은 **비대각(off-diagonal)** 이라고 한다. **모든 비대각 요소가 0인 행렬을 대각행렬(diagonal matrix)** 이라고 한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic17.PNG)

~~~python
np.diag([1,2,3])
~~~

~~~
array([[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])
~~~

### 항등행렬
대각행렬 중에서도 모든 대각성분의 값이 1인 대각행렬을 **항등행렬(identity matrix)** 라고 한다. 항등행렬은 보통 알파벳 문자 I로 표기한다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic18.PNG)

~~~python
np.identity(3)
~~~

~~~
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
~~~

~~~python
np.eye(3)
~~~

~~~
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])
~~~

### 대칭행렬
만약 전치연산을 통해 얻은 전치행렬과 원래의 행렬이 같으면 **대칭행렬(symmetric matrix)** 라고 한다.
> 정방행렬만 대칭행렬이 될 수 있다.

![Alt text](/public/post/2020_04_15_math_dt_1_3/pic19.PNG)
